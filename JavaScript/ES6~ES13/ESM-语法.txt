CommonJS(服务器) | AMD(浏览器)

require 用在浏览器的劣势：运行时加载，无法做静态优化

------------💖 ESM 💖------------
两个重要关键字：import、export
import：规定模块的对外接口
export：输入其他模块提供的功能

1. 模块导入导出的并不是对象，是接口
2. 是编译时加载，也可以叫静态加载
3. 对于一个模块，JS 会自动开启严格模式(ES5内容)，尤其重要的一点就是，模块顶层的 this 为 undefined

------------💖 export 导出关键字 💖------------
1. export 输出的是接口，与其值是动态绑定关系，即通过该接口，可取到模块内实时的值
这与 CJS 完全不同，CJS 输出的是值得缓存，并不存在动态更新
  
2. export 输出的变量就是原来的名字，但可以用 as 关键字重命名

3. export default 一个模块只能有一个默认输出
本质上，export default 就是输出一个叫 default 的变量或方法，然后系统允许你为它取任意名字
即 export default 是将后面的值，赋给 default 变量，所以可以直接将一个值写在 default 后面
如 export default 42 可以，因为导出了 default 接口
而 export 42 就不行，因为必须导出一个接口，42这个值并不是接口

4. export * as xxx from 'module'

------------💖 import 导入关键字 💖------------
1. import 是静态执行，故不可用表达式和变量

2. import 命令输入的变量都是只读的，因为本质上是接口
但若为对象，依旧是可以修改上面的属性，但最好不要这么做，一定要把它当作一个只读的接口

3. import 命令有提升效果
如 foo(); import {foo} from 'module';
会先执行 import，因为对于 ESM ，引擎处理时是编译时加载，并不会运行实际的 JS 代码
注意：这里可以利用函数提升，解决部分循环引用的问题，因为函数提升时 JS 代码并没有被实际运行，只是编译阶段

4. 这样设计，也导致了无法在运行时加载模块，语法上，条件加载就不可能实现
即 import 无法取代 require 动态加载功能

5. 对此，ES2020 引入了 import() 函数，参数就是 指定索要加载的模块的位置
import() 可在任何地方，不仅仅是模块，非模块脚本也可使用
它是运行时执行，什么时候运行到这一句，就会去异步加载指定模块

6. 注意：import() 类似 NodeJS 的 require()
主要区别为：import() 为异步加载，require() 为同步加载

7. import * as xxx from 'module'